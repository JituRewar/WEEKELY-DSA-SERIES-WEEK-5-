# ğŸš€ Week 5 - Day 4  
## ğŸ€ Rat in a Maze (Backtracking)

### ğŸ§© Problem Statement
A rat is placed at the top-left corner of a maze represented by a square matrix `mat[][]` of size `n x n`.  
- The rat can move **Down (D), Up (U), Right (R), or Left (L)**.  
- A cell with `1` means open path and `0` means blocked.  
- The rat needs to reach the **bottom-right cell (n-1, n-1)**.  
- Print all possible paths in **lexicographical order**.

---

### ğŸ’¡ Approach
This problem is solved using **Backtracking**:
1. Start from the source `(0,0)` and explore all possible directions.  
2. Mark the current cell as visited (`-1`) while exploring.  
3. If a path reaches the destination, add it to the answer list.  
4. Backtrack by unmarking the current cell before returning.

---

### ğŸ§® Time & Space Complexity
- **Time Complexity:** `O(4^(n*n))` in the worst case (exploring all paths).  
- **Space Complexity:** `O(n*n)` due to recursion stack and visited tracking.

---

### ğŸ§‘â€ğŸ’» Code
```cpp
  #include<iostream>
#include<vector>
using namespace std;
void helper(vector<vector<int>> &mat,int r,int c,string path,vector<string> &ans){
int n=mat.size();
        if(r<0 || c<0 ||r>=n ||c>=n||mat[r][c]==0 || mat[r][c]==-1){
            return;
        }
        if(r==n-1 && c==n-1){
            ans.push_back(path);
            return;
        }

        mat[r][c] = -1;

        helper(mat,r+1,c,path+"D",ans);
        helper(mat,r-1,c,path+"U",ans);
        helper(mat,r,c+1,path+"R",ans);
        helper(mat,r,c-1,path+"L",ans);

        mat[r][c] = 1;

    }

    vector<string> findPath(vector<vector<int>> &mat){
        int n=mat.size();
        vector<string> ans;
        string path = "";
        helper(mat,0,0,path,ans);
        return ans;
    }
int main(){
vector<vector<int>> mat={{1,0,0,0},{1,1,0,1},{1,1,0,0},{0,1,1,1}};
vector<string> ans=findPath(mat);
for(string path:ans){
    cout<< path <<endl;
}

    return 0;
}
